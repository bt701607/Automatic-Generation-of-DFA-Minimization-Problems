% !TeX spellcheck = en_US
\documentclass[a4paper, oneside, 11pt]{report}

\usepackage[a4paper,width=150mm,top=25mm,bottom=25mm]{geometry}

%packages for german language
\usepackage[utf8]{inputenc}
\usepackage[english]{babel}
\usepackage[T1]{fontenc}
\usepackage{lmodern}

\usepackage{graphicx}
\graphicspath{ {images/} }

\usepackage{amsmath}
\usepackage{amsthm}
\usepackage{amssymb}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode} % [noend]

% ------------------------

\newtheorem{theorem}{Theorem}
\newtheorem{corollary}{Corollary}
\newtheorem{lemma}{Lemma}

\theoremstyle{definition}
\newtheorem{definition}{Definition}

\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%
\newcommand{\MinMark}{\textsc{MinimizationMark}}

% Title Page
\title{Generation of DFA Minimization Problems}
\author{Gregor H. C. SÃ¶nnichsen}

\begin{document}
\maketitle

%\begin{abstract}
%	Abstract goes here
%\end{abstract}

%\chapter*{Acknowledgements}
%I want to thank...

\tableofcontents

\chapter{Introduction}

\section{Preliminaries}

\begin{itemize}
	\item def of isomorphic dfas
	\item statement that minimal dfa is unique besides isomorphism
\end{itemize}

\subsection{Finite Automatons}

A 5-tuple $A = (Q, \Sigma, \delta, s, F)$ with $Q$ as set of \emph{states}, $\Sigma$ as \emph{input alphabet}, $\delta \colon\ Q \times \Sigma \to Q$ as \emph{transition function}, $s \in Q$ as \emph{start state} and $F \subseteq Q$ as \emph{finite states} is called \emph{deterministic finite automaton} (DFA).

From now on $\mathcal{A}$ shall denote the set of all DFAs. We will call $\delta(q,\sigma) = p$ a \emph{transition from $q$ to $p$ using symbol $\sigma$}.
We define the \emph{extended transition function} $\delta^* : Q \times \Sigma^* \to Q$ of a DFA $A = (Q, \Sigma, \delta, s, F)$:
\begin{itemize}
	\item $\delta^*(q,\varepsilon) = q$
	\item $\delta^*(q,w\sigma) = \delta(\delta^*(q,w),\sigma)$ for all $q \in Q$, $w \in \Sigma^*$, $\sigma \in \Sigma$
\end{itemize}
Given a DFA $A = (Q, \Sigma, \delta, s, F)$ and a state $q \in Q$. We call all transitions $\delta(q', \sigma) = q$, $q'\in Q$, $\sigma\in\Sigma$, \emph{ingoing transitions of $q$}. All transitions $\delta(q, \sigma) = q'$, $q'\in Q$, $\sigma\in\Sigma$, are called \emph{outgoing transitions of $q$}.

We say a state $q$ is \emph{(un-)reachable} in an DFA $A$, iff there is (no) a word $w \in \Sigma^*$ such that $\delta^*(s, w) = q$.

States that are reachable but have only ingoing transitions are named \emph{sink-states}.
If a state has neither ingoing nor outgoing transitions, then it is called \emph{lonely}.
If a transition is of the form $\delta(q, \sigma) = q$, $\sigma\in\Sigma$, then we say that $q$ has a \emph{loop}.

\subsection{Minimal DFAs}

The \emph{Nerode-relation} $\equiv_L\ \subseteq\ \Sigma^* \times \Sigma^*$ of a language $L$ with alphabet $\Sigma$ is defined as follows:
\begin{displaymath}
	x \equiv_L y\ \Leftrightarrow_{def}\ \forall z\in\Sigma^*\colon (xz\in L \Leftrightarrow yz\in L)
\end{displaymath}
Thus the Nerode-relation of a DFA $A$ is exactly $\equiv_{L(A)}$. If the context makes it clear, than we will shorten the notation of a equivalence class $[x]_{\equiv_L}$ with $[x]$.

\begin{theorem}
	A language $L$ is regular if and only if the number of equivalence classes of $\equiv_L$ is finite.
\end{theorem}

The \emph{equivalence class automaton} $A_L = (Q_L, \Sigma_L, \delta_L, s_L, F_L)$ to a regular language $L$ with alphabet $\Sigma$ is defined as follows:
\begin{itemize}
	\item $Q_L = \{\ [x]\ |\ x \in \Sigma^*\ \}$
	\item $\Sigma_L = \Sigma$
	\item $\delta_L([x], \sigma) = [x\sigma],\ \forall x\in\Sigma^*,\ \forall\sigma\in\Sigma$
	\item $s = [\varepsilon]$
	\item $F = \{\ [x]\ |\ x \in L\ \}$
\end{itemize}
We call a DFA $A$ \emph{minimal}, if there exists no other automaton with the same language using less states.
\begin{corollary}
	Given a language $L$, then the equivalence class automaton $A_L$ is minimal.
\end{corollary}

\begin{definition}[Duplicate States]
	Two states $q_1, q_2 \in Q$ of a finite automaton $A = (Q, \Sigma, \delta, s, F)$ are called \emph{duplicates} of each other, iff $d_A(q_1, q_2)$ is true, whereas
	\[
		d_A = \{\ (p, q)\ |\ \forall z \in \Sigma^* \colon\ \delta^*(p, z) \in F \Leftrightarrow \delta^*(q, z) \in F\ \}
	\]
\end{definition}

\subsection{The minimization algorithm}

The minimization algorithm works in three main steps.
\begin{enumerate}
	\item Remove all unreachable states.
	\item Compute $\neg d_A(p, q)$ via the \MinMark-algorithm.
	\item Merge all node pairs, which are not in $\neg d_A(p, q)$.
\end{enumerate}

\begin{algorithmic}[1]
	\Function{MinimizationMark}{$(Q, \Sigma, \delta, s, F)$}
	\State $M \gets \{ (p,q), (q,p)\ |\ p \in F, q \notin F \}$
	\Do
		\State $M' \gets \{ (p,q)\ |\ (p,q) \notin M \land \exists \sigma \in \Sigma \colon (\delta(p,\sigma), \delta(q,\sigma)) \in M \}$
		\State $M \gets M \cup M'$
	\doWhile {$M' \neq \emptyset$}
	\State \Return $M$
	\EndFunction
\end{algorithmic}
We will denote the number of iterations $n \in \mathbb{N}$ done by \MinMark on an DFA $A$ as $minmarkDepth(A)$.

\section{Problem Definition}

heuristic:
\begin{itemize}
	\item $h \colon \mathcal{A} \times \mathcal{A} \to \mathbb{R^+}$
	\item $h(A_{min}, A_{task}) = studentfriendliness$
\end{itemize}

\section{Structure of this Work}



\chapter{DFA requirements and following implications}

\section{Heuristics for the friendlieness of dfas}

\begin{itemize}
	\item $h(A_{min}, A_{task}) = |Q_{task}|\ /\ |Q_{min}|$
	\item number of transitions
	\item max degree of a node
	\item planarity (can be checked in $O(|Q_{task}|)$)
	\item Does GraphViz have a heuristic?
	\item[->] number of duplicate states
	\item[->] number of minimization algorithm iterations ($depth_min(A)$)
	\item[->] number of unreachable states
\end{itemize}

\section{Proofs for validity of separate steps}

\begin{theorem}[]
	Adding duplicate states to an automaton $A$ does not increase the number of iterations in the \MinMark-algorithm for $A$.
\end{theorem}

\begin{proof}
	\begin{description}
		\item
		
		Proof per contradiction.
		
		Let's assume adding a duplicate state $q_d$ to a given automaton $A = (Q, \Sigma, \delta, s, F)$ results in an automaton $A' = (Q', \Sigma, \delta', s, F')$ whereas $minmarkDepth(A') > minmarkDepth(A)$.
		
		Concerning $A'$ we can say the following:
		\begin{itemize}
			\item $Q' = Q \cup \{ q_d \}$
			\item $\delta \subseteq \delta'$
			\item $F \subseteq F'$
			\item $\exists q \in Q \colon\ d_A(q, q_d)$
		\end{itemize}
		
		\begin{lemma}
			\begin{multline*}
				minmarkDepth(A) =\ n \Leftrightarrow \\
				n = \max_{n \in \mathbb{N}}\ \ \exists p, q \in Q\ \ \exists w \in \Sigma^* \colon \\
				|w| = n - 1 \land (\delta^*(p,w) \in F \Leftrightarrow \delta^*(q,w) \notin F)
			\end{multline*}
		\end{lemma}
	
		\ldots
	\end{description}
\end{proof}

\begin{lemma}[]
	Adding unreachable states to an automaton does not alter the number of iterations in the \MinMark-algorithm in the context of the minimization algorithm.
\end{lemma}

\begin{proof}
	\ldots
\end{proof}

As a result, we will set $depth\_min(A)$ when building the minimal DFA.

We will add duplicate and unreachable states afterwards.


\chapter{Building minimal DFAs}

%When building the minimal DFA, we do not want to have duplicates.
%
%\begin{align*}
%	f(0) &= F \\
%	f(n + 1) &= \{\ q\ |\ \exists p\in f(n),\ \sigma\in\Sigma\colon\ \delta(q,\sigma) = p\ \}
%\end{align*}
%Based on this we define

We want an algorithm for dfa generation that fulfills the following conditions:
\begin{itemize}
	\item the resulting dfa is minimal
	\item we can control $minmarkDepth$ of the resulting dfa via paramter
	\item we can control the number of states of the resulting dfa via parameter
\end{itemize}
The resulting algorithm will work iterative, such that states are added one by one.
At first, we define two functions.

We take a closer look at the \MinMark-algorithm now, to see when exactly new iterations are needed. %Since duplicate states do not effect this, we assume from now on, that the input dfa is minimal.

When looking at the \MinMark-algorithm, one notes, that it does compute a distinct subsets of $Q \times Q$ on the way. Indeed, one could write it in such a way, that these subsets (in form of a function $m\colon\mathbb{N}\to\mathcal{P}(Q\times Q)$) are explicitly computed:

\begin{algorithmic}[1]
	\Function{MinimizationMark}{$(Q, \Sigma, \delta, s, F)$}
	\State $i \gets 0$
	\State $m(0) \gets \{ (p,q), (q,p)\ |\ p \in F, q \notin F \}$
	\Do
	\State $i \gets i + 1$
	\State $m(i) \gets \{ (p,q)\ |\ (p,q) \notin \bigcup{m(\cdot)} \land \exists \sigma \in \Sigma \colon (\delta(p,\sigma), \delta(q,\sigma)) \in m(i-1) \}$
	\doWhile {$m(i) \neq \emptyset$}
	\State \Return $\bigcup{m(\cdot)}$
	\EndFunction
\end{algorithmic}
We see that $minmarkDepth(A) = \max n\in\mathbb{N}\colon m(n-1)\neq\emptyset$.

Based on $m$ we define a new function, 

\chapter{Extending minimal DFAs}

First, a systematic study of how to extend minimal DFAs will be done. Afterwards, we will define an extension algorithm, which will use the previously found results.

\section{Adding new elements to DFAs}

Our study of DFA extension possibilities will focus on methods, that add or remove transitions or states. In general, we could also change start and accepting nodes, but we will exclude these possibilities here. As a consequence, we may now classify our options as follows:
\begin{enumerate}
	\item Add states without transitions
	\item Add transitions without states
	\item Add states and transitions such that
	\begin{itemize}
		\item At least one state is added
		\item No new state has no transitions
	\end{itemize}
	\item Remove/add states and transitions such that
	\begin{itemize}
		\item At least one state or transition is removed
	\end{itemize}
\end{enumerate}
Adding states $p_1, \ldots, p_n$ leads to the situation, that $p_1, \ldots, p_n$ are lonely states. Since adding lonely states does not affect an automatons language, we can use this as option to extend DFAs.

Adding new transitions does not work because of minimal automaton isomorphism \ldots

For option 3, we can not tell yet, whether it will generate usable automatons. The two additional conditions guarantee, that the generated automatons are distinct from the ones generated by options 1 and 2 \\

\noindent One could imagine, that removing transitions/states and adding new ones again might generate distinct automatons in relation to option 3. However, we can prove, that each automaton generated by this technique is isomorphic to an automaton generated by option 3.

\begin{proof}
	To a given language $L$ only one minimal automaton $A_L$ (despite isomorphism) exists.
	So every "remove-add"-automaton $A_{ra}$ can be transformed to $A_L$ using the minimization algorithm.
	The minimization algorithm does in particular delete some states and transitions.
	Thus adding these states and transitions to $A_L$ is the way to simulate the generation via "remove-add" through generation via "just-add".
\end{proof}
\noindent As a consequence, we will discuss from now on only option 3 in more detail.

\section{Add states and transitions}

We classify several subcases:

\begin{enumerate}
	\item New states have ingoing transitions only
	\begin{enumerate}
		\item All new states are non-accepting
		\item At least one state is accepting
	\end{enumerate}
	\item New states have outgoing transitions only
	\item New states have both in- and outgoing transitions
\end{enumerate}
Adding states $p_0, \ldots, p_n$ with ingoing transitions is okay, if every $p_i$ is non-accepting and thus a sink-state.

We prove that adding accepting states with ingoing transitions only leads to a NFA or to a DFA with a different language.
\begin{proof}
	If a new state $p$ is accepting and if w.l.o.g.\ $\delta(q, \sigma) = p$, then there are several cases:
	\begin{itemize}
		\item $p$ is unreachable: Then we got at least one unreachable sub-graph consisting of more than one states
		\item $p$ is reachable: Then the language of the original automaton (call it $A_{orig}$) is not preserved. This is because of the following:
		
		If $A_{orig}$ were in state $q$ after reading $w \in \Sigma^*$ with $\sigma$ as next Symbol, then there would have to exist a transition $\delta(q, \sigma) = p'$ whereas $p' \in F$ is an accepting state. But this would imply that $A_{orig}$ is an NFA (contradiction).
	\end{itemize}
\end{proof}

\noindent 2. leads to the new state being unreachable or the dfa having a different language.

Thus we remain with option 3, which states that every new state has at least one ingoing transition and at least one outgoing transition.

\section{New states have both in- and outgoing transitions}

\section{Controlling number of minimization iterations}

We define a function, that defines the set of states marked for each round of the minimization algorithm. \\
$f_A \colon \mathbb{N} \to \mathcal{P}(Q^2)$ \\
$f_A(0) = \{ (p,q) | p \in F, q \notin F \}$ \\
$f_A(n+1) = \{ (p,q) | (p,q) \notin \bigcup\limits_{0 \dots n}f(n), \exists \sigma \in \Sigma \colon (\delta(p,\sigma), \delta(q,\sigma)) \in \bigcup\limits_{0 \dots n}f(n)\}$ \\
This function can be naturally computed alongside the minimization algorithm.


\section{The DFA extension algorithm}

\subsection{Usable results}

1. Add states only -> unreachable and sink-state \\
2. Add transitions only -> does not increase state number \\
3. Add/Remove states and transitions -> generated by 4. too \\
4.1. Adding states with ingoing transitions only -> sink-states, NFA or different lang. \\
4.2. Adding states with outgoing transitions only -> unreachable \\
4.3.1. Adding states and duplicate at least its ingoing transitions -> NFA \\
4.3.2. Adding states, split ingoing, duplicate outgoing -> generated by 4.3.2.1. too \\
4.3.2.1. Adding states, split ingoing, split outgoing s.t. $[\delta(q', \sigma_i)]_{\equiv_L} = [\delta(q'', \sigma_i)]_{\equiv_L}$ -> Ok


\subsection{The algorithm}




\chapter{Display DFAs}




\chapter{Conclusion}

What happens, if we change start and accepting states? \\
What happens, if we add transitions only?


\appendix
\chapter{List of Figures}
\chapter{Bibliography}

\end{document}          
