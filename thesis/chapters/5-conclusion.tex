% !TeX spellcheck = en_US

\chapter{Conclusion}

Our intention was to investigate approaches, how DFA minimization task could be generated automatically. Therefore we discussed requirements to such a program and used some of them to formalize the underlying problems. Our approach to solve those problems was to first generate the minimal solution DFA and afterwards the task DFA by adding equivalent states and unreachable DFAs. This structure was derived from Hopcrofts minimization algorithm.

We did the generation of minimal DFAs via a rejection algorithm using either randomized and enumerating; we rejected in particular DFAs with a language which was found already in a previous run. A short overview over research on this topic confirmed our direction but gave outlook to more efficient variants.

On making minimal DFAs non-minimal no results in research was found. The properties of equivalent state pairs and unreachable states however gave precise and easy applicable rules to add such elements.

When building the task DFA, a question arised concerning the number of iterations by the \CompDist-algorithm ($\mmD$), which we wanted to be adjustable via parameter. By proving that the $\mmD$-value does not change if we extend minimal DFAs, we could ensure that this value is already set when building the solution DFA, so DFAs could be rejected already in this stage, if $\mmD$ did not match.

We close this work with a short lookout.

During our requirements analysis we defined several parameters that have not been or only sparsely further discussed in here. This includes especially boundaries for the number of ingoing transitions to each state and drawing DFAs in a visual comprehensible manner. Connected to the latter is the question, whether a good procedure exists, that outputs a visual representation of a DFA via \LaTeX-code, such that hand-made adjustments might be done afterwards. One could also think of making more parameters ranged, such that per instance a minimum and maximum number of states could be specified as input.

Regarding the planarity test as it is used now, one might ask whether there is a more efficient planarity test that is tailored to DFAs. Moreover it could be worth investigating whether informations generated during the planarity test can be used for drawing the DFA.

Our summary on research on DFA generation indicated that efficient - randomized and enumerating - methods to generate DFAs have already been found, where the resulting DFAs where even accessible. An improved version of the associated implementation could implement some of these methods or make use of existing implementations. We shall cite in this regard the enumeration method of Almeida et. al.~\cite{AAA09} which uses a similar string representation of DFAs to iterate through all DFAs. Carayol and Nicaud~\cite{CN12} presented a randomization method that is deemed easy to implement.

Concerning the process of extending solution DFAs to task DFAs, one might ask, how an enumeration algorithm similar to the one for generating solution DFAs could work. In doing so, one might furthermore think about the chance of hitting the same task DFA twice, when the extension algorithm is applied two times on the same DFA.
