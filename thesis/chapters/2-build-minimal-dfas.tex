% !TeX spellcheck = en_US

\chapter{Building solution DFAs} \label{ch:2}

\gregor{argue that and why we make A sol complete}

We want an algorithm for DFA generation that fulfills the following conditions:
\begin{itemize}
	\item[->] minimal
	\item[->] number of states
	\item[->] number of \MinMark\ iterations ($\mmD(A_{sol})$)
	\item[->] alphabet size
	\item[->] number of accepting states
	\item[->] planarity (can be checked in $O(|Q_{sol}|)$)
	\item[->] $A_{sol}$ is unused (regarding all previously generated solution DFAs)
\end{itemize}

\begin{definition}[BuildNewMinimalDFA] $ $
	\begin{description}
		
		\item[Given:] $ $
		
		$q, a, f, m_{min}, m_{max} \in \mathbb{N},$
		
		$p \in \{0,1\}$
		\item[Request:] $ $
		
		Let $A_{sol} = (Q, \Sigma, \delta, s, F)$ be a DFA, such that
		
		\qquad $|Q|=q$, $|\Sigma|=a$, $|F|=f$,
		
		\qquad $m_{min} \le \mmD(A_{sol}) \le m_{max}$,
		
		\qquad $A_{sol}$ is planar iff $p = 1$ and
		
		\qquad the language of $L(A)$ is unequal to any DFA used before.
		
		Return $A_{sol}$, if it exists, $\bot$ otherwise.
	\end{description}
\end{definition}

\section{Using trial and error}

We will develop an algorithm that makes partly use of the trial-and-error paradigm to find matching DFAs. The approach here is as follows:

Firstly a \emph{test} DFA $A_{test}$ is generated by use of either randomness or enumeration. Alphabet size and number of (final) states will already be correct. On this DFA then tests will be executed, to check if it is minimal, planar (if wished) and unused. If this is the case, $A_{test}$ will be returned, if not, new test DFAs are generated until all tests pass.

By constructing test DFAs with already correct alphabet size and number of (final) states we are able to subdivide the search space of DFAs in advance into much smaller pieces.

\gregor{How much smaller?}

\vspace{0.2cm}
\begin{algorithmic}[1]
	\Function{BuildNewMinimalDFA\ }{
		
$q, a, f, m_{min}, m_{max} \in \mathbb{N},$

$p \in \{0,1\}$

}
		\While {True}
			\State generate DFA $A_{test}$ with $|Q|, |\Sigma|, |F|$ matching $q, a, f$
			
			\If {$A_{test}$ not minimal \textbf{or not} $m_{min} \leq \mmD(A_{test}) \leq m_{max}$}
				\State \textbf{continue}
			\EndIf
			
			\If {$p = 1$ \textbf{and} $A_{test}$ is not planar}
				\State \textbf{continue}
			\EndIf
			
			\If {$A_{test}$ was used before}
				\State \textbf{continue}
			\EndIf
			
			\State\Return $A_{test}$
		\EndWhile
	\EndFunction
\end{algorithmic}
\vspace{0.2cm}
We will complete this algorithm by resolving how the tests in lines $4, 6$ and $8$ work and by showing two methods for generation of test automatons.

\subsection{Ensuring $A_{test}$ is minimal and $\mmD(A_{test})$ is correct}

In order to test, whether $A_{test}$ is minimal, we could simply use the minimization algorithm and compare the resulting DFA and $A_{test}$ using an isomorphy test. However it is sufficient to ensure, that no duplicate or unreachable states exist.

To get $\mmD(A_{test})$, we have to run \MinMark\ entirely anyway. Hence we can combine the test for duplicate states with computing the DFAs $\mmD$-value:
\vspace{0.2cm}
\begin{algorithmic}[1]
	\Function{HasDuplicateStates}{$A$}
		\State $depth \gets 0$
		\State $M \gets \{ (p,q), (q,p)\ |\ p \in F, q \notin F \}$
		\Do
			\State $depth \gets depth + 1$
			\State $M' \gets \{ (p,q)\ |\ (p,q) \notin M \land \exists \sigma \in \Sigma \colon (\delta(p,\sigma), \delta(q,\sigma)) \in M \}$
			\State $M \gets M \cup M'$
		\doWhile {$M' \neq \emptyset$}
		\State $hasDupl \gets | \{ (p,q)\ |\ p \neq q \land (p,q) \notin M \} | > 0$
		\State \Return $hasDupl, depth$
	\EndFunction
\end{algorithmic}
\vspace{0.2cm}
Since \MinMark\ computes all non-duplicate state pairs $\neg d_A$, we test in line $9$, whether there is a pair of distinct states not in $\neg d_A$.

Regarding the unreachable states, we can just use \textsc{ComputeUnreachableStates} and test whether the computed set is empty:
\vspace{0.2cm}
\begin{algorithmic}[1]
	\Function{HasUnreachableStates}{$A$}
	\State \Return $|\textsc{ComputeUnreachableStates}(A)| > 0$
	\EndFunction
\end{algorithmic}
\gregor{Is there a more efficient method? Since we actually need to know of only one unreachable state.}

\subsection{Ensuring $A_{test}$ is planar}

There exist several algorithms for planarity testing of graphs. In this work, the library \emph{pygraph}\footnote{\url{https://github.com/jciskey/pygraph}} has been used, which implements the Hopcroft-Tarjan planarity algorithm. More information on this can be found for example in this~\cite{kocay93} introduction from William Kocay. The original paper describing the algorithm is~\cite{hopcroft74}.

\subsection{Ensuring $A_{test}$ is unused}

In our requirements we stated, that we wanted the generated solution DFA to be unused with regards to all previous generated solution DFAs. This implies the need of a database, that allows saving single DFAs and loading DFAs. We name this database \emph{DB1}. Assuming the database is relational, the following scheme is proposed:
\begin{center}
	\begin{tabular}{c c c c c c}
	$|Q_A|$ & |$\Sigma_A$| & $|F_A|$ & $\mmD(A)$ & $isPlanar(A)$ & $encode(A)$
	\end{tabular}
\end{center}
With this scheme we can fetch once all DFAs matching the search parameters. Thus we need not fetch all used DFAs every time, but only those that are relevant. Afterwards we must only check whether any isomorphy test on the current test DFA and one of the fetched DFAs is positive. If any test DFA passes all tests and is going to be returned, then we have to save that DFA in the database.

A more concrete specification of this proceeding is shown below, embedded in the main algorithm:
\vspace{0.2cm}
\begin{algorithmic}[1]
	\Function{BuildNewMinimalDFA\ }{$q, a, f, m_{min}, m_{max}, p$}
		\State $l \gets$ all DFAs in DB1 matching $q, a, f, m_{min}, m_{max}, p$
		\While {True}
			\State $\ldots$
			\For {$A$ \textbf{in} $l$}
				\If {$A_{test}$ is isomorph to $A$}
					\State \textbf{continue}
				\EndIf
			\EndFor
			\State save $A_{test}$ and its respective properties in DB1
			\State\Return $A_{test}$
		\EndWhile
	\EndFunction
\end{algorithmic}
\vspace{0.2cm}

\subsection{Option 1: Generating $A_{test}$ via Randomness}

\subsection{Option 2: Generating $A_{test}$ via Enumeration}

\paragraph*{DB2 - Enumeration Progress}

\begin{tabular}{c c c c c}
	|Q| & |$\Sigma$| & f & t & finished
\end{tabular}\\
f and t are the encoded final states respectively transitions enumeration progresses for the given |Q| and |$\Sigma$| (and f in case of t). With this table the enumeration room is split into smaller pieces.

\paragraph*{The enumeration algorithm}

\vspace{0.2cm}
\begin{algorithmic}[1]
	\Function{BuildNewMinimalDFA\ }{$q, a, f, m_{min}, m_{max}, p$}
		\State $l \gets$ load based on all parameters
		\State $e \gets$ load enumeration progress for $q, a, f, p$
		\While {True}
			\If {$e$ is finished}
				\State save $e$
				\State\Return $\bot$
			\EndIf
			
			\State $A_L \gets$ next DFA based on $e$
			
			\If {$A_L$ not minimal}
				\State \textbf{continue}
			\EndIf
			
			\If {$p = 1$ \textbf{and} $A_L$ is not planar}
				\State \textbf{continue}
			\EndIf
			
			\If {$A_L$ isomorph to any DFA in $l$ matching with $q, a, f, m_{min}, m_{max}, p$}
				\State \textbf{continue}
			\EndIf
			
			\State save $e$
			\State save $l \cup A_L$
			\State\Return $A_L$
		\EndWhile
	\EndFunction
\end{algorithmic}
\vspace{0.2cm}

\subsection{Ideas for more efficiency}

incrementing final state binary faster in enum-alternative

speed up isomorphy test

rewrite everything in C

solve P vs NP

\section{Alternative approach: Building $m(i)$ bottom up}

Build $m$ from $m$-\MinMark\ iteratively. (Why would this basically result in running \MinMark\ all the time?)
