\documentclass[10pt,usenames,dvipsnames]{beamer}% handout,

\usepackage{ucs}
\usepackage[utf8x]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

\usepackage{bm}

\usepackage{xcolor}
\usepackage{tikz}
\usetikzlibrary{arrows, matrix, shapes.geometric}
\usetikzlibrary{calc,fit,positioning,automata}

\usepackage{algorithm}
\usepackage[noend]{algpseudocode}


% -----------

\algdef{SE}[DOWHILE]{Do}{doWhile}{\algorithmicdo}[1]{\algorithmicwhile\ #1}%

\newcommand{\MinAlg}{\textsc{MinimizeDFA}}
\newcommand{\CompUnr}{\textsc{FindUnreachables}}
\newcommand{\RemUnr}{\textsc{RemUnreachables}}
\newcommand{\CompDist}{\textsc{FindEquivPairs}}
\newcommand{\mCompDist}{\textsc{$m$-FindEquivPairs}}
\newcommand{\RemEq}{\textsc{RemEquivPairs}}

\newcommand{\mmD}{\mathfrak{D}}

\newcommand{\nSO}{{n_s}}
\newcommand{\nEQ}{{n_e}}
\newcommand{\nUN}{{n_u}}
\newcommand{\nF}{{n_F}}
\newcommand{\kAL}{k}

\newcommand{\A}{\mathcal{A}}
\newcommand{\Amin}{{\mathcal{A}_{min}}}

\newcommand{\gregorColor}{violet}
\newcommand{\gregor}[1]{\textcolor{\gregorColor}{#1}}

\newcommand{\x}{$\blacksquare$}

\setbeamertemplate{footline}[frame number]

% -----------

\title{Automatic Generation of DFA Minimization Problems}

\author{Gregor Sönnichsen}
\institute{Universität Bayreuth}
\subject{Bachelors Thesis}


\usetheme{default}
\usecolortheme{whale}
\definecolor{darkgreen}{RGB}{3,138,94}
\setbeamercolor{frametitle}{bg=darkgreen}
\setbeamercolor*{title}{bg=darkgreen, fg=white}
\setbeamertemplate{navigation symbols}{}

\bibliographystyle{plainurl}



\begin{document}
	
	\begin{frame}
		\titlepage
	\end{frame}
	
	% Introduction
	
	\section{Introduction}
	
	\begin{frame}
		\frametitle{Introduction}
		Automata theory is a classical topic in computer science curricula.
		
		Minimization of DFAs is a typical task for students:
		\begin{itemize}
			\item<2-> sufficiently easy to understand
			\item<2-> practical applications
			\item<2-> understanding can be tested easily
		\end{itemize}
		\vspace{0.3cm}
		\uncover<3->{Consequently, studying automatized generation of DFA minimization problems is interesting because it could\ldots}
		\begin{itemize}
			\item<4-> \ldots free up precious time for exercise constructors
			
			(if a generator is implemented)
			\item<4-> \ldots yield a deeper insight
			
			in the nature of such problems
		\end{itemize}
	\uncover<4->{
		{\vspace{-2cm}\hfill\includegraphics[width=0.2\linewidth]{zeitdiebe-besiegen-lebenszeit-gewinnen.jpg}\hspace{0.1cm}\tiny\footnotemark}
		
		\renewcommand{\footnotesize}{\tiny}
		
		{\footnotetext{\url{https://www.rindlerwahn.de/zeitdiebe-besiegen-und-mehr-lebenszeit-gewinnen}}}
	}
	\end{frame}
	
	% Thesis Content
	
	\section{Problem definition and approach}
	
	\begin{frame}
		\frametitle{Outline}
		\tableofcontents[currentsection] % [pausesections]
	\end{frame}
	
	\begin{frame}
		\frametitle{Problem definition}
		\framesubtitle{Preliminaries (1/2)}
		
		A tuple $A = (Q, \Sigma, \delta, s, F)$ with $Q, \Sigma$ being a finite, $\delta \colon\ Q \times \Sigma \to Q$, $s \in Q$ and $F \subseteq Q$ is called \emph{deterministic finite automaton}.
		\vspace{0.3cm}
		
		% Note: Completeness
		
		We define the \emph{extended transition function} $\delta^* : Q \times \Sigma^* \to Q$ as:
		\begin{itemize}
			\item $\delta^*(q,\varepsilon) = q$
			\item $\delta^*(q,w\sigma) = \delta(\delta^*(q,w),\sigma)$ for all $q \in Q$, $w \in \Sigma^*$, $\sigma \in \Sigma$
		\end{itemize}
		\vspace{0.3cm}
		
		The \emph{language} of DFA is defined as $L(A) = \{\ w\ |\ \delta^*(w) \in F\ \}$.
		\vspace{0.3cm}
		
		We call a DFA \emph{minimal}, if there exists no other DFA with the same language having less states.
	\end{frame}
		
	\begin{frame}
		\frametitle{Problem definition}
		\framesubtitle{Preliminaries (2/2)}
		
		We say a state $q$ is \emph{unreachable}, iff there is no word $w \in \Sigma^*$ such that $\delta^*(s, w) = q$.
		\vspace{0.3cm}
		
		A state pair $q_1, q_2 \in Q$ is called \emph{equivalent}, iff $\sim_A(q_1, q_2)$ is true, where
		\begin{displaymath}
		q_1 \sim_A q_2\ \Leftrightarrow_{def}\ \forall z \in \Sigma^* \colon\ (\delta^*(q_1, z) \in F \Leftrightarrow \delta^*(q_2, z) \in F)
		\end{displaymath}\pause
		\begin{example}
			\centering
			\begin{tikzpicture}[initial text={}]
			\tikzstyle{every state}=[minimum size=5mm, inner sep=0pt]
			
			\node[initial, state]  (0) at (0, 0) {$0$};
			
			\node[state]           (1) at (1.5,-1) {$1$};
			\node[state]           (2) at (1.5, 1) {$2$};
			
			\node[accepting,state] (3) at (3, 0) {$3$};
			
			\node[state]           (4) at (4.5,0) {$4$};
			
			\path[->]
			(0) edge node [above right]  {$a$} (1)
			(0) edge node [above left]  {$b$} (2)
			
			(1) edge node [above left=-0.1cm] {$a,b$} (3)
			(2) edge node [above right=-0.1cm] {$a,b$} (3)
			
			(3) edge [loop below] node [right] {$a,b$} (3)
			
			(4) edge node [above] {$a,b$} (3)
			;
			\end{tikzpicture}
		\end{example}\pause
	
		\begin{theorem}
			A DFA is minimal, iff it has neither unreachable nor equivalent states.
		\end{theorem}
	\end{frame}


	\begin{frame}
		\frametitle{Problem definition}
		\framesubtitle{Hopcroft's Minimization Algorithm}
		
		\begin{tikzpicture}[remember picture,overlay]
		\node[xshift=-1.5cm,yshift=-3cm] at (current page.north east) {\includegraphics[height=2.5cm]{jehyoung.jpg}};
		\end{tikzpicture}
		
		\begin{enumerate}
		\item Compute all unreachable states
		\item Remove all unreachable states and their transitions
		\item Compute all inequivalent state pairs ($\not\sim_A$)
		\begin{algorithmic}[1]
			\Function{\CompDist}{$A$}
			\State $i \gets 0$
			\State $m(0) \gets \{ (p,q), (q,p)\ |\ p \in F, q \notin F \}$
			\Do
			\State $i \gets i + 1$
			\State $m(i) \gets \{ (p,q), (q,p)\ |\ (p,q) \notin \bigcup{m(\cdot)} \land$
			\State \hfill$\exists \sigma \in \Sigma \colon (\delta(p,\sigma), \delta(q,\sigma)) \in m(i-1) \}$
			\doWhile {$m(i) \neq \emptyset$}
			\State \Return $\bigcup{m(\cdot)}$
			\EndFunction
		\end{algorithmic}
		\item Merge all equivalent state pairs
		\end{enumerate}
	\end{frame}

	
	\begin{frame}
		\frametitle{Problem definition}
		\framesubtitle{A sample DFA minimization task\ldots}
		{\raggedright\itshape \underline{Task:} Consider the below shown deterministic finite automaton $A$:}
		\begin{center}\resizebox{.75\linewidth}{!}{
				\begin{tikzpicture}[initial text={},scale=1., every node/.style={transform shape}]
				\tikzstyle{every state}=[minimum size=5mm, inner sep=0pt]
				
				\node[initial, state]  (0) at (0, 0)    {$0$};
				\node[state] 		   (1) at (6, 0)    {$1$};
				\node[state,accepting] (2) at (4,0)     {$2$};
				\node[state]           (3) at (2, -1.5) {$3$};
				\node[state,accepting] (4) at (4,-3)    {$4$};
				\node[state]           (5) at (4,-1.5)  {$5$};
				\node[state]           (6) at (2,0)     {$6$};
				
				\path[->]
				(0) edge node [above=-0.07cm]  {$a$}   (6)
				(0) edge [bend left] node [above=-0.07cm]  {$b$}   (2)
				
				(1) edge node [above=-0.07cm]  {$a$}   (2)
				(1) edge node [below right=-0.15cm]  {$b$}   (4)
				
				(2) edge [bend left] node [above=-0.07cm]  {$a$}   (1)
				(2) edge node [below right=-0.15cm]  {$b$}   (3)
				
				(3) edge node [left=-0.07cm]  {$a$}   (6)
				(3) edge node [above right=-0.15cm]  {$b$}   (4)
				
				(4) edge [bend right] node [below right=-0.15cm]  {$a$}   (1)
				(4) edge [bend left] node [below left=-0.15cm]  {$b$}   (0)
				
				(5) edge node [below right=-0.15cm]  {$a$}   (1)
				(5) edge node [left=-0.07cm]  {$b$}   (4)
				
				(6) edge [bend right] node [below=-0.07cm]  {$a$}   (1)
				(6) edge node [above=-0.07cm]  {$b$}   (2)
				;
				\end{tikzpicture}
		}\end{center}
		{\itshape Apply the minimization algorithm and illustrate for each state pair of $A$ during which \CompDist-iteration it was marked. Draw the resulting automaton.}
		
	\end{frame}


	\begin{frame}
		\frametitle{Problem definition}
		\framesubtitle{\ldots and its solution}
	
		{\raggedright\itshape \underline{Solution:}\newline
			Step 1: Detect and eliminate unreachable states.
			\begin{tabbing}
				\qquad\textnormal{State $5$ is unreachable.}
			\end{tabbing}
			Step 2: Apply \CompDist\ to $A$ and merge equivalent state pairs:\par
		}
		\begin{columns}
		\begin{column}{.4\textwidth}
			\vspace{0.5cm}
			\qquad
			\begin{tabular}{c|c|c|c|c|c|c}
				& 0  & 1  & 2  & 3  & 4  & 6  \\\hline
				0 & \x & 1  & 0  &    & 0  & 2  \\\hline
				1 & \x & \x & 0  & 1  & 0  & 1  \\\hline
				2 & \x & \x & \x & 0  &    & 0  \\\hline
				3 & \x & \x & \x & \x & 0  & 2  \\\hline
				4 & \x & \x & \x & \x & \x & 0  \\\hline
				6 & \x & \x & \x & \x & \x & \x \\
			\end{tabular}
		\end{column}
		\begin{column}{.5\textwidth}\centering\resizebox{1.\linewidth}{!}{
			\begin{tikzpicture}[initial text={},scale=1., every node/.style={transform shape}]
			\tikzstyle{every state}=[minimum size=5mm, inner sep=0pt]
			
			\node[initial, state]  (03) at (0, 0)   {$03$};
			\node[state] 		   (1) at (6, 0)   {$1$};
			\node[state,accepting] (24) at (4,0)    {$24$};
			\node[state]           (6) at (2,0)    {$6$};
			
			\path[->]
			(03) edge node [above=-0.07cm]  {$a$}   (6)
			(03) edge [bend left] node [above=-0.07cm]  {$b$}   (24)
			
			(1) edge node [above=-0.13cm]  {$a,b$}   (24)
			
			(24) edge [bend left=50] node [above=-0.07cm]  {$a$}   (1)
			(24) edge [bend right=50] node [above=-0.07cm]  {$b$}   (03)
			
			(6) edge [bend right] node [below=-0.07cm]  {$a$}   (1)
			(6) edge node [above=-0.07cm]  {$b$}   (24)
			;
			\end{tikzpicture}
		}\end{column}
		\end{columns}
	\end{frame}

	\begin{frame}
		\frametitle{Problem Definition and Approach}
		Problem: How to generate a \emph{DFA Minimization Problem} $A_{task}$?
		
		\vspace{0.2cm}
		Idea: First generate $A_{sol}$, then add equivalent, then unreachable states.
		
		$\Rightarrow$ modular pipeline architecture
		
		\vspace{0.4cm}
		\begin{tikzpicture}[initial text={}, every node/.style={transform shape}]
		
		\node[draw,style={rounded corners}] (p) at (0,0) {$\nSO, \kAL, \nF, d, p_{sol}, p_{task}, \nEQ,\nUN, c$};
		
		\node[draw] (1) at (0,-2) {
			\begin{minipage}{\linewidth}
			Generate DFA Minimization Problem
			
			\begin{itemize}
				\item Generate Minimal DFA
				
				\qquad (using a rejection algorithm and randomization/enumeration)
				
				\item Extend Minimal DFA
				\begin{itemize}
					\item Add Equivalent States
					\item Add Unreachable States
				\end{itemize}
			\end{itemize}
			
			\end{minipage}
		};
	
		\node[draw,style={rounded corners}] (o) at (0,-4) {$A_{task}$};
		
		\path[->]
		(p) edge (1)
		(1) edge (o)
		;
		\end{tikzpicture}
		
	\end{frame}
	
	
	\section{Generating Minimal DFAs}
	
	\begin{frame}
		\frametitle{Outline}
		\tableofcontents[currentsection] % [pausesections]
	\end{frame}
	
	\begin{frame}
		\frametitle{Generating Minimal DFAs}
		\framesubtitle{Rejection Algorithm}
		Approach: Generate test DFAs until they match the demanded properties.
		
		\vspace{0.2cm}
		\begin{algorithmic}[1]
			\Function{GenNewMinDFA\ }{$\nSO, \kAL, \nF, d, p$}
			
			\vspace{0.2cm}
			
			\State $l \gets$ all DFAs in DB$_{found}$ matching $\nSO, \kAL, \nF$
			
			\vspace{0.2cm}
			
			\While {True}
			
				\vspace{0.2cm}
				
				\State generate DFA $A_{test}$ with $|Q|, |\Sigma|, |F|$ matching $\nSO, \kAL, \nF$
	
				\vspace{0.2cm}
				
				\If {$A_{test}$ not minimal \textbf{or} $d \neq \mmD(A_{test})$}
					\State \textbf{continue}
				\EndIf
				
				\If {$p = 1$ \textbf{and} $A_{test}$ is not planar}
					\State \textbf{continue}
				\EndIf
				
				\If {$A_{test}$ is isomorph to any DFA in $l$}
					\State \textbf{continue}
				\EndIf
				
				\vspace{0.2cm}
				
				\State save $A_{test}$ and its respective properties in DB$_{found}$
				\State\Return $A_{test}$
			
			\EndWhile
			\EndFunction
		\end{algorithmic}
	
		\begin{tikzpicture}[remember picture,overlay]
		\node[xshift=-1.5cm,yshift=-6.25cm] at (current page.north east) {\includegraphics[height=1.75cm]{rejection.jpg}};
		\end{tikzpicture}
	
	\end{frame}

	\begin{frame}
		\frametitle{Generating Minimal DFAs}
		\framesubtitle{Test DFA Generation}
		We will restrict ourselves to the following DFAs:
		\[
			Q = \mathbb{N}_0^ {\nSO-1}, \Sigma = \mathbb{N}_0^{\kAL-1}, s = 0
		\]\pause
		
		\begin{enumerate}
			\item[(a)] Generation by Randomization:
			\begin{align*}
			F &= random\_subset(Q)\\
			\delta(q, \sigma) &= choose\_one(Q) \qquad\qquad \forall q\in Q, \sigma\in\Sigma
			\end{align*}\pause
			
			\item[(b)] Generation by Enumeration:\\$ $\\
			An \emph{enumeration state} $s_{\nSO, \kAL, \nF} = (F_F,F_\delta)$ consists of two arrays of length $\nSO, \nSO*\kAL$, respectively.
			\begin{align*}
			F_F[i] = 1 &\Leftrightarrow_{def} i \in F\\
			F_\delta[i * \kAL + j] = q &\Leftrightarrow_{def} \delta(i, j) = q
			\end{align*}
			Example state: $s_{4, 2, 2} = (0110)_2\ \ (10\ 13\ 22\ 03)_4$
		\end{enumerate}
	
	\end{frame}

%	\begin{frame}
%		\frametitle{Generating Minimal DFAs}
%		\framesubtitle{Incrementing Enumeration States}
%		
%		\gregor{Short demo how the associated DFA changes, when an enumeration state is incremented}
%	
%	\end{frame}
	
	\section{Extending Minimal DFAs}
	
	\begin{frame}
		\frametitle{Outline}
		\tableofcontents[currentsection] % [pausesections]
	\end{frame}
	
	\input{./add_eq.tex}

	\begin{frame}
		\frametitle{Extending Minimal DFAs}
		\framesubtitle{Adding Unreachable States}
	
		Reminder: We say a state $q$ is \emph{unreachable}, iff there is no word $w \in \Sigma^*$ such that $\delta^*(s, w) = q$.
		\vspace{0.3cm}
	
		\begin{algorithmic}[1]
			\Function{AddUnrStates\ }{$A, \nUN, c$}
			\State $U \gets \emptyset$
			\vspace{0.2cm}
			
			\For {$\nUN$ \textbf{times}}
				\vspace{0.2cm}
				
				\State let $q$ be the new state
				\vspace{0.2cm}
				
				\State add ingoing tr.\ from a random subset of $U\times\Sigma$
				\vspace{0.2cm}
				
				\State $\Sigma' \gets \textbf{if } c = 1 \textbf{ then } \Sigma \textbf{ else}$ random subset of $\Sigma$
				\State add outgoing tr.\ to $|\Sigma'|$ random states
				\vspace{0.2cm}
				
				\State add $q$ to $U$
			\EndFor
			\vspace{0.2cm}
			
			\State \Return $A$
			\EndFunction
		\end{algorithmic}
%	
%		\begin{tikzpicture}[remember picture,overlay]
%		\node[xshift=-1.5cm,yshift=-7.5cm] at (current page.north east) {\includegraphics[height=1.75cm]{Fix-err-address-unreachable.jpg}};
%		\end{tikzpicture}
	
	\end{frame}

	\section{Live Demonstration and Conclusion}
	
	\begin{frame}
		\frametitle{Outline}
		\tableofcontents[currentsection] % [pausesections]
	\end{frame}
	
	\begin{frame}
		\frametitle{Live Demonstration}
		\framesubtitle{Program Architecture}
		\begin{tikzpicture}[initial text={}, every node/.style={transform shape}]
		
		\node[draw] (main) at (0,0) {main.py};
		
		\node[draw,style={rounded corners}] (log) at (3,0) {log.py};
		
		\node[draw] (build) at (-3,-1.5) {build.py};
		\node[draw] (extend) at (0,-1.5) {extend.py};
		\node[draw] (output) at (3,-1.5) {output.py};
		
		\node[draw] (dbdfa) at (-4,-3) {db\_dfa.py};
		\node[draw] (dbenum) at (-2,-3) {db\_enum.py};
		
		\node[draw] (iso) at (-3, -4.5) {isomorphy.py};
		\node[draw] (min) at (0, -4.5) {minimization.py};
		\node[draw] (plan) at (3, -4.5) {planarity.py};
		
		\node[draw, fit=(iso)(plan)] (iso) at (0, -5.3) {dfa.py};
		
		\path[->]
			(main) edge (log)
			
			(main) edge (build)
			(main) edge (extend)
			(main) edge (output)
			
			(build) edge (dbdfa)
			(build) edge (dbenum)
		;
		\end{tikzpicture}
	\end{frame}

%	\begin{frame}
%		\frametitle{Live Demonstration}
%		\framesubtitle{Command-Line Options}
%		
%		\includegraphics[width=\linewidth]{options.jpg}
%		\gregor{Replace}
%	
%	\end{frame}
	
%	\section{Conclusion}
	
%	\begin{frame}
%		\frametitle{Outline}
%		\tableofcontents[currentsection] % [pausesections]
%	\end{frame}

	\begin{frame}
		\frametitle{Conclusion}
		
		This presentation has\ldots
		\begin{itemize}
			\item introduced the problem of DFA Minimization Problem Generation
			\item given an overview over a possible solution
			\item shown that the theoretic results might be useful in praxis
		\end{itemize}\pause
		Lookout:
		\begin{itemize}
			\item more parameters, ranged parameters
			
			The \emph{degree} of a state $q$ is defined as $deg(q) = |in(q)| + |out(q)|$.
			
			$\Rightarrow$ capping the max.\ degree?
			
			\item investigate planarity and drawing algorithms
			\item complexity analysis
		\end{itemize}
	
	\end{frame}

%	\begin{frame}
%		\frametitle{References}
%		
%		\tiny
%		\bibliography{presentation}
%		
%	\end{frame}

\end{document}

